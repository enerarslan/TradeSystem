"""
Signal events for event-driven backtesting.

This module provides signal event types:
- SignalEvent: Trading signals from strategies
- SignalType: Classification of signal types

Designed for institutional requirements:
- Signal strength/confidence levels
- Multi-strategy signal attribution
- Full audit trail
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

import pandas as pd

from src.backtesting.events.base import Event, EventType, EventPriority


class SignalType(str, Enum):
    """Types of trading signals."""

    # Directional signals
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"
    EXIT = "EXIT"

    # Specific entry signals
    ENTRY_LONG = "ENTRY_LONG"
    ENTRY_SHORT = "ENTRY_SHORT"

    # Exit signals
    EXIT_LONG = "EXIT_LONG"
    EXIT_SHORT = "EXIT_SHORT"

    # Adjustment signals
    INCREASE = "INCREASE"
    DECREASE = "DECREASE"
    REBALANCE = "REBALANCE"

    # Risk signals
    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"
    RISK_REDUCE = "RISK_REDUCE"


@dataclass(frozen=True)
class SignalEvent(Event):
    """
    Trading signal event.

    Represents a trading signal generated by a strategy
    with full attribution and confidence metrics.

    Attributes:
        symbol: Trading symbol
        signal_type: Type of signal
        signal_value: Signal strength/direction (-1 to +1)
        target_weight: Target portfolio weight
        strategy_name: Name of strategy generating signal
        model_name: Name of ML model (if applicable)
        confidence: Signal confidence (0 to 1)
        features: Key features that drove the signal
        stop_loss: Suggested stop loss price
        take_profit: Suggested take profit price
        expiry: Signal expiration timestamp
        reason: Human-readable reason for signal
    """

    symbol: str = ""
    signal_type: SignalType = SignalType.FLAT
    signal_value: float = 0.0
    target_weight: Optional[float] = None
    strategy_name: str = ""
    model_name: Optional[str] = None
    confidence: float = 1.0
    features: Dict[str, float] = field(default_factory=dict)
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    expiry: Optional[pd.Timestamp] = None
    reason: str = ""

    def __post_init__(self):
        object.__setattr__(self, 'event_type', EventType.SIGNAL)

    @property
    def is_long(self) -> bool:
        """Check if signal is long."""
        return self.signal_type in (SignalType.LONG, SignalType.ENTRY_LONG) or self.signal_value > 0

    @property
    def is_short(self) -> bool:
        """Check if signal is short."""
        return self.signal_type in (SignalType.SHORT, SignalType.ENTRY_SHORT) or self.signal_value < 0

    @property
    def is_exit(self) -> bool:
        """Check if signal is an exit."""
        return self.signal_type in (
            SignalType.EXIT,
            SignalType.EXIT_LONG,
            SignalType.EXIT_SHORT,
            SignalType.FLAT,
        )

    @property
    def is_risk_signal(self) -> bool:
        """Check if signal is risk-related."""
        return self.signal_type in (
            SignalType.STOP_LOSS,
            SignalType.TAKE_PROFIT,
            SignalType.RISK_REDUCE,
        )

    @property
    def is_valid(self) -> bool:
        """Check if signal is still valid (not expired)."""
        if self.expiry is None:
            return True
        return pd.Timestamp.now() < self.expiry

    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "timestamp": str(self.timestamp),
            "created_at": self.created_at.isoformat(),
            "priority": self.priority.value,
            "source": self.source,
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "signal_value": self.signal_value,
            "target_weight": self.target_weight,
            "strategy_name": self.strategy_name,
            "model_name": self.model_name,
            "confidence": self.confidence,
            "features": self.features,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "expiry": str(self.expiry) if self.expiry else None,
            "reason": self.reason,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SignalEvent":
        return cls(
            event_type=EventType.SIGNAL,
            timestamp=pd.Timestamp(data["timestamp"]),
            event_id=data.get("event_id", str(uuid.uuid4())),
            created_at=datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.utcnow(),
            priority=EventPriority(data.get("priority", EventPriority.NORMAL)),
            source=data.get("source", "strategy"),
            symbol=data.get("symbol", ""),
            signal_type=SignalType(data.get("signal_type", "FLAT")),
            signal_value=data.get("signal_value", 0.0),
            target_weight=data.get("target_weight"),
            strategy_name=data.get("strategy_name", ""),
            model_name=data.get("model_name"),
            confidence=data.get("confidence", 1.0),
            features=data.get("features", {}),
            stop_loss=data.get("stop_loss"),
            take_profit=data.get("take_profit"),
            expiry=pd.Timestamp(data["expiry"]) if data.get("expiry") else None,
            reason=data.get("reason", ""),
            metadata=data.get("metadata", {}),
        )


@dataclass(frozen=True)
class CompositeSignalEvent(Event):
    """
    Composite signal from multiple strategies.

    Aggregates signals from multiple sources for
    ensemble-based decision making.

    Attributes:
        symbol: Trading symbol
        component_signals: List of individual signals
        aggregated_value: Combined signal value
        aggregation_method: Method used to combine signals
        weights: Weights used for each component
    """

    symbol: str = ""
    component_signals: List[SignalEvent] = field(default_factory=list)
    aggregated_value: float = 0.0
    aggregation_method: str = "weighted_average"
    weights: Dict[str, float] = field(default_factory=dict)

    def __post_init__(self):
        object.__setattr__(self, 'event_type', EventType.SIGNAL)

    @property
    def num_signals(self) -> int:
        """Number of component signals."""
        return len(self.component_signals)

    @property
    def average_confidence(self) -> float:
        """Average confidence across components."""
        if not self.component_signals:
            return 0.0
        return sum(s.confidence for s in self.component_signals) / len(self.component_signals)

    @property
    def agreement_ratio(self) -> float:
        """
        Ratio of signals agreeing on direction.

        Returns:
            Agreement ratio (0 to 1)
        """
        if not self.component_signals:
            return 0.0

        directions = [
            1 if s.signal_value > 0 else (-1 if s.signal_value < 0 else 0)
            for s in self.component_signals
        ]

        if not directions:
            return 0.0

        majority = max(set(directions), key=directions.count)
        return directions.count(majority) / len(directions)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "timestamp": str(self.timestamp),
            "created_at": self.created_at.isoformat(),
            "priority": self.priority.value,
            "source": self.source,
            "symbol": self.symbol,
            "component_signals": [s.to_dict() for s in self.component_signals],
            "aggregated_value": self.aggregated_value,
            "aggregation_method": self.aggregation_method,
            "weights": self.weights,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CompositeSignalEvent":
        component_signals = [
            SignalEvent.from_dict(s) for s in data.get("component_signals", [])
        ]

        return cls(
            event_type=EventType.SIGNAL,
            timestamp=pd.Timestamp(data["timestamp"]),
            event_id=data.get("event_id", str(uuid.uuid4())),
            created_at=datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.utcnow(),
            priority=EventPriority(data.get("priority", EventPriority.NORMAL)),
            source=data.get("source", "ensemble"),
            symbol=data.get("symbol", ""),
            component_signals=component_signals,
            aggregated_value=data.get("aggregated_value", 0.0),
            aggregation_method=data.get("aggregation_method", "weighted_average"),
            weights=data.get("weights", {}),
            metadata=data.get("metadata", {}),
        )


def create_signal(
    symbol: str,
    signal_type: SignalType,
    signal_value: float,
    strategy_name: str,
    timestamp: Optional[pd.Timestamp] = None,
    confidence: float = 1.0,
    **kwargs,
) -> SignalEvent:
    """
    Create a signal event.

    Args:
        symbol: Trading symbol
        signal_type: Type of signal
        signal_value: Signal strength/direction
        strategy_name: Name of strategy
        timestamp: Signal timestamp (default: now)
        confidence: Signal confidence
        **kwargs: Additional signal attributes

    Returns:
        SignalEvent instance
    """
    return SignalEvent(
        event_type=EventType.SIGNAL,
        timestamp=timestamp or pd.Timestamp.now(),
        symbol=symbol,
        signal_type=signal_type,
        signal_value=signal_value,
        strategy_name=strategy_name,
        confidence=confidence,
        source=strategy_name,
        **kwargs,
    )


def aggregate_signals(
    signals: List[SignalEvent],
    method: str = "weighted_average",
    weights: Optional[Dict[str, float]] = None,
) -> CompositeSignalEvent:
    """
    Aggregate multiple signals into a composite signal.

    Args:
        signals: List of signals to aggregate
        method: Aggregation method (weighted_average, majority, max_confidence)
        weights: Strategy weights (default: equal weighting)

    Returns:
        CompositeSignalEvent with aggregated signal
    """
    if not signals:
        raise ValueError("Cannot aggregate empty signal list")

    symbol = signals[0].symbol
    timestamp = max(s.timestamp for s in signals)

    # Default to equal weights
    if weights is None:
        weights = {s.strategy_name: 1.0 / len(signals) for s in signals}

    # Aggregate based on method
    if method == "weighted_average":
        total_weight = sum(weights.get(s.strategy_name, 1.0) for s in signals)
        aggregated = sum(
            s.signal_value * weights.get(s.strategy_name, 1.0)
            for s in signals
        ) / total_weight

    elif method == "majority":
        votes = sum(1 if s.signal_value > 0 else -1 for s in signals if s.signal_value != 0)
        aggregated = 1.0 if votes > 0 else (-1.0 if votes < 0 else 0.0)

    elif method == "max_confidence":
        best_signal = max(signals, key=lambda s: s.confidence)
        aggregated = best_signal.signal_value

    else:
        aggregated = sum(s.signal_value for s in signals) / len(signals)

    return CompositeSignalEvent(
        event_type=EventType.SIGNAL,
        timestamp=timestamp,
        symbol=symbol,
        component_signals=signals,
        aggregated_value=aggregated,
        aggregation_method=method,
        weights=weights,
        source="ensemble",
    )
