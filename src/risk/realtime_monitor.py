"""
Real-time Risk Monitoring for AlphaTrade System.

JPMorgan-level implementation of continuous risk monitoring:
- Position risk tracking
- P&L monitoring
- Exposure limits
- VaR updates
- Alert generation

This module provides active monitoring during trading sessions.
"""

from __future__ import annotations

import json
import threading
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

import numpy as np
import pandas as pd
from loguru import logger


class AlertSeverity(Enum):
    """Severity levels for risk alerts."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


@dataclass
class RiskAlert:
    """A risk alert generated by the monitoring system."""

    timestamp: datetime
    severity: AlertSeverity
    category: str
    message: str
    metric_name: str
    current_value: float
    threshold: float
    acknowledged: bool = False
    acknowledged_by: str | None = None
    acknowledged_at: datetime | None = None


@dataclass
class PositionRisk:
    """Risk metrics for a single position."""

    symbol: str
    quantity: float
    market_value: float
    unrealized_pnl: float
    realized_pnl: float
    weight: float  # Portfolio weight
    var_contribution: float
    beta: float
    volatility: float
    last_update: datetime


@dataclass
class PortfolioRiskSnapshot:
    """Point-in-time snapshot of portfolio risk metrics."""

    timestamp: datetime
    total_value: float
    cash: float
    invested: float
    gross_exposure: float
    net_exposure: float
    total_unrealized_pnl: float
    total_realized_pnl: float
    daily_pnl: float
    daily_pnl_pct: float
    var_95: float
    var_99: float
    cvar_95: float
    current_drawdown: float
    max_drawdown: float
    sharpe_ratio: float
    position_count: int
    long_count: int
    short_count: int
    largest_position_weight: float
    sector_exposures: Dict[str, float] = field(default_factory=dict)


class RiskMetrics:
    """Calculator for various risk metrics."""

    @staticmethod
    def calculate_var(
        returns: np.ndarray,
        confidence: float = 0.95,
        method: str = "historical",
    ) -> float:
        """Calculate Value at Risk."""
        if len(returns) == 0:
            return 0.0

        if method == "historical":
            return float(-np.percentile(returns, (1 - confidence) * 100))
        elif method == "parametric":
            mean = np.mean(returns)
            std = np.std(returns)
            z_score = {0.95: 1.645, 0.99: 2.326}.get(confidence, 1.645)
            return float(-(mean - z_score * std))
        else:
            return float(-np.percentile(returns, (1 - confidence) * 100))

    @staticmethod
    def calculate_cvar(
        returns: np.ndarray,
        confidence: float = 0.95,
    ) -> float:
        """Calculate Conditional VaR (Expected Shortfall)."""
        if len(returns) == 0:
            return 0.0

        var = RiskMetrics.calculate_var(returns, confidence)
        tail_returns = returns[returns <= -var]

        if len(tail_returns) == 0:
            return var

        return float(-np.mean(tail_returns))

    @staticmethod
    def calculate_beta(
        asset_returns: np.ndarray,
        market_returns: np.ndarray,
    ) -> float:
        """Calculate asset beta relative to market."""
        if len(asset_returns) == 0 or len(market_returns) == 0:
            return 1.0

        if len(asset_returns) != len(market_returns):
            min_len = min(len(asset_returns), len(market_returns))
            asset_returns = asset_returns[-min_len:]
            market_returns = market_returns[-min_len:]

        cov = np.cov(asset_returns, market_returns)[0, 1]
        var = np.var(market_returns)

        if var == 0:
            return 1.0

        return float(cov / var)


class RealTimeRiskMonitor:
    """
    Real-time risk monitoring system.

    Continuously monitors portfolio risk and generates alerts when
    limits are breached.
    """

    def __init__(
        self,
        config: Dict[str, Any] | None = None,
        alert_callback: Callable[[RiskAlert], None] | None = None,
    ) -> None:
        """
        Initialize the risk monitor.

        Args:
            config: Risk limits configuration
            alert_callback: Function to call when alerts are generated
        """
        self.config = config or {}
        self._alert_callback = alert_callback

        # Risk limits from config
        self._limits = {
            "max_var_pct": self.config.get("var_limits", {}).get("max_var_pct", 0.03),
            "max_cvar_pct": self.config.get("var_limits", {}).get("max_cvar_pct", 0.05),
            "max_drawdown": self.config.get("drawdown", {}).get("max_drawdown_pct", 0.20),
            "max_position_weight": self.config.get("exposure", {}).get("max_single_position", 0.20),
            "max_gross_exposure": self.config.get("exposure", {}).get("max_gross_exposure", 1.5),
            "max_net_exposure": self.config.get("exposure", {}).get("max_net_exposure", 1.0),
            "max_sector_exposure": self.config.get("exposure", {}).get("max_sector_exposure", 0.40),
            "daily_loss_limit": self.config.get("loss_limits", {}).get("daily_loss_limit", 0.03),
            "weekly_loss_limit": self.config.get("loss_limits", {}).get("weekly_loss_limit", 0.06),
        }

        # Warning thresholds (as fraction of limit)
        self._warning_thresholds = self.config.get("monitoring", {}).get("alerts", {})

        # State tracking
        self._positions: Dict[str, PositionRisk] = {}
        self._snapshots: List[PortfolioRiskSnapshot] = []
        self._alerts: List[RiskAlert] = []
        self._returns_history: List[float] = []

        # Reference values
        self._daily_start_value: float | None = None
        self._weekly_start_value: float | None = None
        self._peak_value: float = 0.0
        self._last_daily_reset: datetime | None = None
        self._last_weekly_reset: datetime | None = None

        # Monitoring thread
        self._monitor_thread: threading.Thread | None = None
        self._stop_event = threading.Event()
        self._check_interval = self.config.get("monitoring", {}).get("check_frequency", 60)

        logger.info("Real-time risk monitor initialized")

    def update_position(
        self,
        symbol: str,
        quantity: float,
        market_value: float,
        unrealized_pnl: float,
        realized_pnl: float = 0.0,
        sector: str | None = None,
    ) -> None:
        """
        Update a position's risk metrics.

        Args:
            symbol: Position symbol
            quantity: Number of shares/contracts
            market_value: Current market value
            unrealized_pnl: Unrealized P&L
            realized_pnl: Realized P&L
            sector: Sector classification
        """
        total_value = self._calculate_total_value()
        weight = market_value / total_value if total_value > 0 else 0.0

        self._positions[symbol] = PositionRisk(
            symbol=symbol,
            quantity=quantity,
            market_value=market_value,
            unrealized_pnl=unrealized_pnl,
            realized_pnl=realized_pnl,
            weight=weight,
            var_contribution=0.0,  # Would need returns data
            beta=1.0,  # Would need market data
            volatility=0.0,  # Would need returns data
            last_update=datetime.now(),
        )

    def update_portfolio_value(self, value: float) -> PortfolioRiskSnapshot:
        """
        Update portfolio value and generate risk snapshot.

        Args:
            value: Current portfolio value

        Returns:
            Risk snapshot
        """
        now = datetime.now()

        # Initialize/reset daily and weekly reference values
        if self._daily_start_value is None or (
            self._last_daily_reset and now.date() > self._last_daily_reset.date()
        ):
            self._daily_start_value = value
            self._last_daily_reset = now

        if self._weekly_start_value is None or (
            self._last_weekly_reset and (now - self._last_weekly_reset).days >= 7
        ):
            self._weekly_start_value = value
            self._last_weekly_reset = now

        # Update peak
        if value > self._peak_value:
            self._peak_value = value

        # Calculate P&L
        daily_pnl = value - self._daily_start_value if self._daily_start_value else 0.0
        daily_pnl_pct = daily_pnl / self._daily_start_value if self._daily_start_value else 0.0

        # Calculate drawdown
        current_drawdown = (self._peak_value - value) / self._peak_value if self._peak_value > 0 else 0.0

        # Calculate exposures
        long_value = sum(p.market_value for p in self._positions.values() if p.quantity > 0)
        short_value = sum(abs(p.market_value) for p in self._positions.values() if p.quantity < 0)
        gross_exposure = (long_value + short_value) / value if value > 0 else 0.0
        net_exposure = (long_value - short_value) / value if value > 0 else 0.0

        # Calculate VaR (simplified - would need proper returns data)
        var_95 = 0.0
        var_99 = 0.0
        cvar_95 = 0.0
        if len(self._returns_history) >= 20:
            returns = np.array(self._returns_history)
            var_95 = RiskMetrics.calculate_var(returns, 0.95) * value
            var_99 = RiskMetrics.calculate_var(returns, 0.99) * value
            cvar_95 = RiskMetrics.calculate_cvar(returns, 0.95) * value

        # Create snapshot
        snapshot = PortfolioRiskSnapshot(
            timestamp=now,
            total_value=value,
            cash=value - long_value - short_value,
            invested=long_value + short_value,
            gross_exposure=gross_exposure,
            net_exposure=net_exposure,
            total_unrealized_pnl=sum(p.unrealized_pnl for p in self._positions.values()),
            total_realized_pnl=sum(p.realized_pnl for p in self._positions.values()),
            daily_pnl=daily_pnl,
            daily_pnl_pct=daily_pnl_pct,
            var_95=var_95,
            var_99=var_99,
            cvar_95=cvar_95,
            current_drawdown=current_drawdown,
            max_drawdown=current_drawdown,  # Would track max over time
            sharpe_ratio=0.0,  # Would need more data
            position_count=len(self._positions),
            long_count=sum(1 for p in self._positions.values() if p.quantity > 0),
            short_count=sum(1 for p in self._positions.values() if p.quantity < 0),
            largest_position_weight=max((p.weight for p in self._positions.values()), default=0.0),
        )

        self._snapshots.append(snapshot)

        # Keep limited history
        if len(self._snapshots) > 1000:
            self._snapshots = self._snapshots[-1000:]

        # Check limits and generate alerts
        self._check_limits(snapshot)

        return snapshot

    def add_return(self, return_value: float) -> None:
        """Add a return observation for VaR calculation."""
        self._returns_history.append(return_value)
        if len(self._returns_history) > 500:
            self._returns_history = self._returns_history[-500:]

    def _check_limits(self, snapshot: PortfolioRiskSnapshot) -> None:
        """Check risk limits and generate alerts."""
        now = datetime.now()

        # Check VaR limit
        if snapshot.total_value > 0:
            var_pct = snapshot.var_99 / snapshot.total_value
            if var_pct > self._limits["max_var_pct"]:
                self._generate_alert(
                    AlertSeverity.CRITICAL,
                    "VaR",
                    f"99% VaR ({var_pct:.2%}) exceeds limit ({self._limits['max_var_pct']:.2%})",
                    "var_99_pct",
                    var_pct,
                    self._limits["max_var_pct"],
                )
            elif var_pct > self._limits["max_var_pct"] * self._warning_thresholds.get("var_warning", 0.8):
                self._generate_alert(
                    AlertSeverity.WARNING,
                    "VaR",
                    f"99% VaR ({var_pct:.2%}) approaching limit ({self._limits['max_var_pct']:.2%})",
                    "var_99_pct",
                    var_pct,
                    self._limits["max_var_pct"],
                )

        # Check drawdown limit
        if snapshot.current_drawdown > self._limits["max_drawdown"]:
            self._generate_alert(
                AlertSeverity.EMERGENCY,
                "Drawdown",
                f"Drawdown ({snapshot.current_drawdown:.2%}) exceeds limit ({self._limits['max_drawdown']:.2%})",
                "current_drawdown",
                snapshot.current_drawdown,
                self._limits["max_drawdown"],
            )
        elif snapshot.current_drawdown > self._limits["max_drawdown"] * self._warning_thresholds.get("drawdown_warning", 0.7):
            self._generate_alert(
                AlertSeverity.WARNING,
                "Drawdown",
                f"Drawdown ({snapshot.current_drawdown:.2%}) approaching limit",
                "current_drawdown",
                snapshot.current_drawdown,
                self._limits["max_drawdown"],
            )

        # Check position concentration
        if snapshot.largest_position_weight > self._limits["max_position_weight"]:
            self._generate_alert(
                AlertSeverity.CRITICAL,
                "Concentration",
                f"Position concentration ({snapshot.largest_position_weight:.2%}) exceeds limit",
                "max_position_weight",
                snapshot.largest_position_weight,
                self._limits["max_position_weight"],
            )

        # Check exposure limits
        if snapshot.gross_exposure > self._limits["max_gross_exposure"]:
            self._generate_alert(
                AlertSeverity.CRITICAL,
                "Exposure",
                f"Gross exposure ({snapshot.gross_exposure:.2f}) exceeds limit ({self._limits['max_gross_exposure']:.2f})",
                "gross_exposure",
                snapshot.gross_exposure,
                self._limits["max_gross_exposure"],
            )

        if abs(snapshot.net_exposure) > self._limits["max_net_exposure"]:
            self._generate_alert(
                AlertSeverity.WARNING,
                "Exposure",
                f"Net exposure ({snapshot.net_exposure:.2f}) exceeds limit ({self._limits['max_net_exposure']:.2f})",
                "net_exposure",
                snapshot.net_exposure,
                self._limits["max_net_exposure"],
            )

        # Check daily loss limit
        if abs(snapshot.daily_pnl_pct) > self._limits["daily_loss_limit"] and snapshot.daily_pnl < 0:
            self._generate_alert(
                AlertSeverity.EMERGENCY,
                "Loss",
                f"Daily loss ({snapshot.daily_pnl_pct:.2%}) exceeds limit ({self._limits['daily_loss_limit']:.2%})",
                "daily_loss_pct",
                abs(snapshot.daily_pnl_pct),
                self._limits["daily_loss_limit"],
            )

    def _generate_alert(
        self,
        severity: AlertSeverity,
        category: str,
        message: str,
        metric_name: str,
        current_value: float,
        threshold: float,
    ) -> None:
        """Generate and store a risk alert."""
        alert = RiskAlert(
            timestamp=datetime.now(),
            severity=severity,
            category=category,
            message=message,
            metric_name=metric_name,
            current_value=current_value,
            threshold=threshold,
        )

        self._alerts.append(alert)

        # Log based on severity
        if severity == AlertSeverity.EMERGENCY:
            logger.error(f"RISK EMERGENCY: {message}")
        elif severity == AlertSeverity.CRITICAL:
            logger.warning(f"RISK CRITICAL: {message}")
        elif severity == AlertSeverity.WARNING:
            logger.warning(f"RISK WARNING: {message}")
        else:
            logger.info(f"RISK INFO: {message}")

        # Callback
        if self._alert_callback:
            try:
                self._alert_callback(alert)
            except Exception as e:
                logger.error(f"Alert callback failed: {e}")

    def _calculate_total_value(self) -> float:
        """Calculate total portfolio value from positions."""
        if self._snapshots:
            return self._snapshots[-1].total_value
        return sum(p.market_value for p in self._positions.values())

    def get_latest_snapshot(self) -> PortfolioRiskSnapshot | None:
        """Get the most recent risk snapshot."""
        return self._snapshots[-1] if self._snapshots else None

    def get_active_alerts(self) -> List[RiskAlert]:
        """Get all unacknowledged alerts."""
        return [a for a in self._alerts if not a.acknowledged]

    def acknowledge_alert(self, alert_index: int, acknowledged_by: str) -> bool:
        """Acknowledge an alert."""
        if 0 <= alert_index < len(self._alerts):
            self._alerts[alert_index].acknowledged = True
            self._alerts[alert_index].acknowledged_by = acknowledged_by
            self._alerts[alert_index].acknowledged_at = datetime.now()
            return True
        return False

    def get_risk_summary(self) -> Dict[str, Any]:
        """Get comprehensive risk summary."""
        snapshot = self.get_latest_snapshot()

        if snapshot is None:
            return {"status": "no_data"}

        return {
            "timestamp": snapshot.timestamp.isoformat(),
            "total_value": snapshot.total_value,
            "daily_pnl": snapshot.daily_pnl,
            "daily_pnl_pct": f"{snapshot.daily_pnl_pct:.2%}",
            "var_99": snapshot.var_99,
            "current_drawdown": f"{snapshot.current_drawdown:.2%}",
            "gross_exposure": f"{snapshot.gross_exposure:.2f}",
            "net_exposure": f"{snapshot.net_exposure:.2f}",
            "position_count": snapshot.position_count,
            "active_alerts": len(self.get_active_alerts()),
            "limits": {
                "var_limit": f"{self._limits['max_var_pct']:.2%}",
                "drawdown_limit": f"{self._limits['max_drawdown']:.2%}",
                "exposure_limit": f"{self._limits['max_gross_exposure']:.2f}",
            },
        }

    def save_state(self, filepath: str | Path) -> None:
        """Save monitor state to file."""
        filepath = Path(filepath)

        state = {
            "daily_start_value": self._daily_start_value,
            "weekly_start_value": self._weekly_start_value,
            "peak_value": self._peak_value,
            "last_daily_reset": self._last_daily_reset.isoformat() if self._last_daily_reset else None,
            "last_weekly_reset": self._last_weekly_reset.isoformat() if self._last_weekly_reset else None,
            "returns_history": self._returns_history[-100:],  # Keep last 100
            "alerts_count": len(self._alerts),
            "active_alerts_count": len(self.get_active_alerts()),
            "saved_at": datetime.now().isoformat(),
        }

        filepath.parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, "w") as f:
            json.dump(state, f, indent=2)

        logger.debug(f"Risk monitor state saved to {filepath}")

    def load_state(self, filepath: str | Path) -> bool:
        """Load monitor state from file."""
        filepath = Path(filepath)

        if not filepath.exists():
            return False

        try:
            with open(filepath, "r") as f:
                state = json.load(f)

            self._daily_start_value = state.get("daily_start_value")
            self._weekly_start_value = state.get("weekly_start_value")
            self._peak_value = state.get("peak_value", 0.0)
            self._returns_history = state.get("returns_history", [])

            last_daily = state.get("last_daily_reset")
            if last_daily:
                self._last_daily_reset = datetime.fromisoformat(last_daily)

            last_weekly = state.get("last_weekly_reset")
            if last_weekly:
                self._last_weekly_reset = datetime.fromisoformat(last_weekly)

            logger.info(f"Risk monitor state loaded from {filepath}")
            return True

        except Exception as e:
            logger.error(f"Failed to load risk monitor state: {e}")
            return False

    def start_monitoring(self) -> None:
        """Start background monitoring thread."""
        if self._monitor_thread and self._monitor_thread.is_alive():
            logger.warning("Monitor already running")
            return

        self._stop_event.clear()
        self._monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self._monitor_thread.start()
        logger.info("Risk monitoring started")

    def stop_monitoring(self) -> None:
        """Stop background monitoring thread."""
        self._stop_event.set()
        if self._monitor_thread:
            self._monitor_thread.join(timeout=5)
        logger.info("Risk monitoring stopped")

    def _monitor_loop(self) -> None:
        """Background monitoring loop."""
        while not self._stop_event.is_set():
            try:
                # Periodic checks would go here
                # In a real system, this would fetch live data
                pass
            except Exception as e:
                logger.error(f"Monitor loop error: {e}")

            self._stop_event.wait(self._check_interval)
