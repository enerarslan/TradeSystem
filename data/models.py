"""
DATA MODELS - PYDANTIC V2 COMPATIBLE
Enterprise Trading System Data Structures

Changes from original:
- Removed frozen=True (causes issues with Pydantic v2)
- Added model_config with frozen=False
- Added validation and serialization methods
- Extended with new model types for advanced strategies

Usage:
    from data.models import MarketTick, TradeSignal, Side
    
    tick = MarketTick(
        symbol="BTC/USDT",
        price=50000.0,
        volume=1.5,
        timestamp=datetime.now(),
        source="binance"
    )
"""

from pydantic import BaseModel, Field, field_validator, ConfigDict
from datetime import datetime
from enum import Enum
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4


# ============================================================================
# ENUMS
# ============================================================================

class Side(str, Enum):
    """Trade direction enum"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class OrderType(str, Enum):
    """Order type enum"""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"
    TRAILING_STOP = "TRAILING_STOP"


class OrderStatus(str, Enum):
    """Order status enum"""
    PENDING = "PENDING"
    SUBMITTED = "SUBMITTED"
    PARTIAL = "PARTIAL"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"


class PositionType(str, Enum):
    """Position type enum"""
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


# ============================================================================
# MARKET DATA MODELS
# ============================================================================

class MarketTick(BaseModel):
    """
    Standard market data packet.
    All data from any exchange is converted to this format.
    
    Note: frozen=False for Pydantic v2 compatibility
    """
    model_config = ConfigDict(frozen=False, validate_assignment=True)
    
    symbol: str = Field(..., description="Trading pair (e.g., BTC/USDT, AAPL)")
    price: float = Field(..., gt=0, description="Current price")
    volume: float = Field(default=0.0, ge=0, description="Volume")
    timestamp: datetime = Field(default_factory=datetime.now)
    source: str = Field(default="unknown", description="Data source (binance, nasdaq, etc.)")
    
    # Optional OHLC data for bar-level ticks
    open: Optional[float] = Field(default=None, gt=0)
    high: Optional[float] = Field(default=None, gt=0)
    low: Optional[float] = Field(default=None, gt=0)
    close: Optional[float] = Field(default=None, gt=0)
    
    # Optional metadata
    bid: Optional[float] = Field(default=None, ge=0)
    ask: Optional[float] = Field(default=None, ge=0)
    bid_size: Optional[float] = Field(default=None, ge=0)
    ask_size: Optional[float] = Field(default=None, ge=0)
    
    @field_validator('symbol')
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper().strip()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return self.model_dump()
    
    def is_valid_ohlc(self) -> bool:
        """Check if OHLC data is valid"""
        if None in (self.open, self.high, self.low, self.close):
            return False
        return self.low <= self.open <= self.high and self.low <= self.close <= self.high


class OHLCV(BaseModel):
    """OHLCV bar data"""
    model_config = ConfigDict(frozen=False)
    
    symbol: str
    timestamp: datetime
    open: float = Field(..., gt=0)
    high: float = Field(..., gt=0)
    low: float = Field(..., gt=0)
    close: float = Field(..., gt=0)
    volume: float = Field(default=0.0, ge=0)
    
    @property
    def typical_price(self) -> float:
        """Calculate typical price (HLC average)"""
        return (self.high + self.low + self.close) / 3
    
    @property
    def range(self) -> float:
        """Calculate bar range"""
        return self.high - self.low
    
    @property
    def body(self) -> float:
        """Calculate candle body"""
        return abs(self.close - self.open)
    
    @property
    def is_bullish(self) -> bool:
        """Check if candle is bullish"""
        return self.close > self.open


# ============================================================================
# SIGNAL MODELS
# ============================================================================

class TradeSignal(BaseModel):
    """
    Trade signal generated by strategy.
    Risk manager will review and approve/reject this signal.
    """
    model_config = ConfigDict(frozen=False, validate_assignment=True)
    
    symbol: str
    side: Side
    price: float = Field(..., gt=0, description="Signal price")
    quantity: float = Field(..., gt=0, description="Suggested quantity")
    strategy_name: str = Field(..., description="Strategy that generated this signal")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Optional signal metadata
    signal_id: str = Field(default_factory=lambda: str(uuid4())[:8])
    confidence: float = Field(default=0.5, ge=0, le=1, description="Signal confidence 0-1")
    stop_loss: Optional[float] = Field(default=None, description="Suggested stop loss")
    take_profit: Optional[float] = Field(default=None, description="Suggested take profit")
    
    # Strategy-specific data
    indicators: Optional[Dict[str, float]] = Field(default=None)
    metadata: Optional[Dict[str, Any]] = Field(default=None)
    
    @field_validator('symbol')
    @classmethod
    def validate_symbol(cls, v: str) -> str:
        return v.upper().strip()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return self.model_dump()


class AlphaSignal(BaseModel):
    """
    Alpha signal with multiple factors.
    Used for more sophisticated strategies.
    """
    model_config = ConfigDict(frozen=False)
    
    symbol: str
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Factor scores (-1 to 1)
    momentum_score: float = Field(default=0.0, ge=-1, le=1)
    mean_reversion_score: float = Field(default=0.0, ge=-1, le=1)
    trend_score: float = Field(default=0.0, ge=-1, le=1)
    volatility_score: float = Field(default=0.0, ge=-1, le=1)
    volume_score: float = Field(default=0.0, ge=-1, le=1)
    
    # Combined alpha
    combined_alpha: float = Field(default=0.0, ge=-1, le=1)
    confidence: float = Field(default=0.0, ge=0, le=1)
    
    # Weights used
    weights: Dict[str, float] = Field(default_factory=dict)
    
    @property
    def direction(self) -> Side:
        """Get trade direction from alpha"""
        if self.combined_alpha > 0.1:
            return Side.BUY
        elif self.combined_alpha < -0.1:
            return Side.SELL
        return Side.HOLD


# ============================================================================
# RISK MODELS
# ============================================================================

class RiskCheckResult(BaseModel):
    """
    Risk check result.
    Contains approval status and any adjustments.
    """
    model_config = ConfigDict(frozen=False)
    
    passed: bool = Field(..., description="Did the signal pass risk checks?")
    adjusted_quantity: float = Field(..., ge=0, description="Risk-adjusted quantity")
    reason: str = Field(default="", description="Reason for rejection/adjustment")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Additional risk metrics
    risk_score: float = Field(default=0.0, ge=0, le=100)
    position_risk: float = Field(default=0.0, ge=0, le=100)
    portfolio_risk: float = Field(default=0.0, ge=0, le=100)
    
    # Warnings
    warnings: List[str] = Field(default_factory=list)


class PortfolioState(BaseModel):
    """
    Current portfolio state.
    Used for risk calculations.
    """
    model_config = ConfigDict(frozen=False)
    
    total_balance: float = Field(..., ge=0, description="Total portfolio value (USD)")
    cash_balance: float = Field(..., ge=0, description="Available cash")
    daily_pnl: float = Field(default=0.0, description="Daily P&L")
    open_positions_count: int = Field(default=0, ge=0)
    daily_trade_count: int = Field(default=0, ge=0)
    
    # Detailed breakdown
    positions_value: float = Field(default=0.0, ge=0)
    unrealized_pnl: float = Field(default=0.0)
    realized_pnl: float = Field(default=0.0)
    
    # Risk metrics
    current_drawdown: float = Field(default=0.0, ge=0)
    peak_balance: float = Field(default=0.0, ge=0)
    margin_used: float = Field(default=0.0, ge=0)
    
    @property
    def drawdown_pct(self) -> float:
        """Calculate drawdown percentage"""
        if self.peak_balance == 0:
            return 0.0
        return (self.peak_balance - self.total_balance) / self.peak_balance * 100
    
    @property
    def cash_ratio(self) -> float:
        """Calculate cash ratio"""
        if self.total_balance == 0:
            return 1.0
        return self.cash_balance / self.total_balance


# ============================================================================
# POSITION & ORDER MODELS
# ============================================================================

class Position(BaseModel):
    """Individual position"""
    model_config = ConfigDict(frozen=False)
    
    symbol: str
    quantity: float = Field(default=0.0)
    avg_price: float = Field(default=0.0, ge=0)
    current_price: float = Field(default=0.0, ge=0)
    position_type: PositionType = Field(default=PositionType.FLAT)
    
    # Timestamps
    opened_at: Optional[datetime] = None
    last_updated: datetime = Field(default_factory=datetime.now)
    
    # P&L
    unrealized_pnl: float = Field(default=0.0)
    realized_pnl: float = Field(default=0.0)
    
    # Risk
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    @property
    def market_value(self) -> float:
        """Calculate market value"""
        return abs(self.quantity) * self.current_price
    
    @property
    def cost_basis(self) -> float:
        """Calculate cost basis"""
        return abs(self.quantity) * self.avg_price
    
    @property
    def pnl_pct(self) -> float:
        """Calculate P&L percentage"""
        if self.cost_basis == 0:
            return 0.0
        return (self.market_value - self.cost_basis) / self.cost_basis * 100
    
    @property
    def is_long(self) -> bool:
        return self.quantity > 0
    
    @property
    def is_short(self) -> bool:
        return self.quantity < 0
    
    @property
    def is_flat(self) -> bool:
        return self.quantity == 0


class Order(BaseModel):
    """Order model"""
    model_config = ConfigDict(frozen=False)
    
    order_id: str = Field(default_factory=lambda: str(uuid4())[:12])
    symbol: str
    side: Side
    order_type: OrderType = Field(default=OrderType.MARKET)
    quantity: float = Field(..., gt=0)
    price: Optional[float] = Field(default=None, gt=0)
    stop_price: Optional[float] = Field(default=None, gt=0)
    
    # Status
    status: OrderStatus = Field(default=OrderStatus.PENDING)
    filled_quantity: float = Field(default=0.0, ge=0)
    avg_fill_price: float = Field(default=0.0, ge=0)
    
    # Timestamps
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    filled_at: Optional[datetime] = None
    
    # Metadata
    strategy_name: str = Field(default="manual")
    commission: float = Field(default=0.0, ge=0)
    slippage: float = Field(default=0.0, ge=0)
    
    @property
    def is_filled(self) -> bool:
        return self.status == OrderStatus.FILLED
    
    @property
    def is_active(self) -> bool:
        return self.status in (OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL)
    
    @property
    def remaining_quantity(self) -> float:
        return self.quantity - self.filled_quantity


class Fill(BaseModel):
    """Order fill/execution"""
    model_config = ConfigDict(frozen=False)
    
    fill_id: str = Field(default_factory=lambda: str(uuid4())[:12])
    order_id: str
    symbol: str
    side: Side
    quantity: float = Field(..., gt=0)
    price: float = Field(..., gt=0)
    commission: float = Field(default=0.0, ge=0)
    
    timestamp: datetime = Field(default_factory=datetime.now)
    
    @property
    def notional_value(self) -> float:
        """Calculate notional value"""
        return self.quantity * self.price
    
    @property
    def total_cost(self) -> float:
        """Calculate total cost including commission"""
        return self.notional_value + self.commission


# ============================================================================
# PAIRS TRADING SPECIFIC MODELS
# ============================================================================

class PairSpread(BaseModel):
    """Pairs trading spread data"""
    model_config = ConfigDict(frozen=False)
    
    symbol_a: str
    symbol_b: str
    price_a: float = Field(..., gt=0)
    price_b: float = Field(..., gt=0)
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Spread metrics
    spread: float = Field(default=0.0)
    zscore: float = Field(default=0.0)
    hedge_ratio: float = Field(default=1.0)
    
    # Cointegration stats
    correlation: float = Field(default=0.0, ge=-1, le=1)
    half_life: float = Field(default=0.0, ge=0)
    
    @property
    def pair_name(self) -> str:
        """Get pair name"""
        return f"{self.symbol_a}/{self.symbol_b}"


class PairSignal(BaseModel):
    """Pairs trading signal"""
    model_config = ConfigDict(frozen=False)
    
    symbol_a: str
    symbol_b: str
    side_a: Side  # Long/Short symbol A
    side_b: Side  # Long/Short symbol B
    
    quantity_a: float = Field(..., gt=0)
    quantity_b: float = Field(..., gt=0)
    
    zscore: float
    confidence: float = Field(default=0.5, ge=0, le=1)
    strategy_name: str = Field(default="PairsTrading")
    timestamp: datetime = Field(default_factory=datetime.now)


# ============================================================================
# BACKTEST MODELS
# ============================================================================

class BacktestTrade(BaseModel):
    """Single backtest trade record"""
    model_config = ConfigDict(frozen=False)
    
    trade_id: str = Field(default_factory=lambda: str(uuid4())[:8])
    symbol: str
    side: str
    
    entry_time: datetime
    exit_time: Optional[datetime] = None
    
    entry_price: float = Field(..., gt=0)
    exit_price: Optional[float] = None
    
    quantity: float = Field(..., gt=0)
    commission: float = Field(default=0.0, ge=0)
    slippage: float = Field(default=0.0, ge=0)
    
    pnl: float = Field(default=0.0)
    pnl_pct: float = Field(default=0.0)
    
    holding_period_hours: float = Field(default=0.0, ge=0)
    strategy_name: str = Field(default="unknown")
    
    @property
    def is_closed(self) -> bool:
        return self.exit_time is not None


class WalkForwardResult(BaseModel):
    """Walk-forward analysis result"""
    model_config = ConfigDict(frozen=False)
    
    window_id: int
    train_start: datetime
    train_end: datetime
    test_start: datetime
    test_end: datetime
    
    # In-sample metrics
    in_sample_return: float = Field(default=0.0)
    in_sample_sharpe: float = Field(default=0.0)
    
    # Out-of-sample metrics
    out_sample_return: float = Field(default=0.0)
    out_sample_sharpe: float = Field(default=0.0)
    
    # Best parameters
    best_params: Dict[str, Any] = Field(default_factory=dict)
    
    # Efficiency ratio
    efficiency_ratio: float = Field(default=0.0)


# ============================================================================
# EXPORTS
# ============================================================================

__all__ = [
    # Enums
    'Side',
    'OrderType',
    'OrderStatus',
    'PositionType',
    
    # Market Data
    'MarketTick',
    'OHLCV',
    
    # Signals
    'TradeSignal',
    'AlphaSignal',
    
    # Risk
    'RiskCheckResult',
    'PortfolioState',
    
    # Position & Orders
    'Position',
    'Order',
    'Fill',
    
    # Pairs Trading
    'PairSpread',
    'PairSignal',
    
    # Backtest
    'BacktestTrade',
    'WalkForwardResult',
]